# 도메인 주도 설계(DDD) 기반 마이크로서비스(MSA) 모델링
## 0. 목차
1. 마이크로서비스 개념
2. 마이크로서비스 개발 프로세스
3. 도메인 주도 설계(전략적 설계)
4. 도메인 주도 설계(전술적 설계)
5. 마이크로서비스 아키텍처 패턴
6. 커뮤니케이션 유형
7. 전략적 설계 기번 - 이벤트 스토밍 워크샵
8. 휴리스틱 설계 - 설계 의사 결정
9. 실습 - 이벤트 스토밍
10. 실습 - 마이크로서비스 별 도메인 모델 정의

## 1. 마이크로서비스 개념
### 1.1. 모노리스
##### 모노리스 시스템
- 애플리케이션이 한 덩어리로 구성
- 단일 프로세스 실행
- 한꺼번에 수정, 배포되어야 함
- 하나가 실패하면 모두 실패됨을 의미
- 모노리스를 클라우드 인프라에서 활용 시에
  - 스케일 아웃의 대상은 모노리스 전체가 됨
  - 그것만으로 충분히 확장성, 탄력성이 보장이 가능하나 비용 상 효율적이지 않음

##### 마이크로서비스
- 마이크로서비스는 애플리케이션이 여러 개의 서비스 조각으로 구성됨
  - 서비스는 각기 독립적인 기능을 제공
  - 서비스가 사용하는 저장소는 다른 서비스와 완벽히 격리됨
  - 따라서 독립적으로 수정 가능하며 별도 배포, 확장 가능
  - 하나의 서비스 실패는 전체 실패가 아닌 부분적인 실패를 의미
- 마이크로서비스 정의
  - Public I/F(Interface), 데이터 캡슐화
  - Martin Fowler
  - 확장 시, 특정 기능별 독립적으로 확장 가능
  - 특정 서비스의 변경 시, 서비스만 빌드, 배포
  - 독립적으로 서로 다른 언어로 개발 가능
  - 여러 개의 작은 서비스 집합으로 개발하는 접근 방법
  - 각 서비스는 개별 프로세스에서 실행
  - HTTP 자원 API 같은 가벼운 수단을 사용하여 통신
  - 서비스는 Biz 기능 단위로 구성
    - 중앙 집중적인 관리 최소화
  - 각 서비스는 서로 다른 언어, 데이터, 저장 기술 사용

## 2. 마이크로서비스 개발 프로세스
### 2.1. 마이크로서비스 개발을 위한 공정
- 스크럼 적용
- 아키텍처 정의
- 프론트 엔드/백엔드 설계
- 제품 백로그 -> 스프린트 계획수립 -> 스프린트 백로그 -> 스프린트 -> 마이크로서비스

### 2.2. 아키텍처 정의
- Outer Architecture 정의
  - Cloud Infra 정의
    - IaaS, PaaS, CaaS
  - Platform 구성요소, MSA 패턴
    - 라우팅, 로드 밸런싱, 인증/인가, 로깅, 트레이싱, 모니터링
  - DevOps Infra 정의
    - 형상관리, 빌드, 배포(CI/CD)
- Inner Architecture 정의
  - Front End
    - 기술 stack 정의
    - 내부 구조 정의
  - Back End
    - 기술 stack, 프레임웍
    - 내부 구조 정의
  - 통신
    - 서비스 간
    - 레거시 연계

### 2.3. 설계/구현
- divide and conquer
- 마이크로서비스 식별
  - 조직구성, 구성원 역량, 비지니스 서비스 성격, 변경/배포 빈도, 사용량, 운영 조직
  - 다양한 마이크로서비스 도출 기법
- 백 엔드 설계
  - 도메인 모델 설계
  - API 설계
  - 데이터 모델 설계
- 프론트 엔드 설계
  - UI 흐름
  - UI 레이아웃 정의
- 테스트
  - 단위
  - API
  - EtoE
- 배포
  - CI/CD

### 2.4. 마이크로서비스 도출
- 고려사항
  - 도메인 : 업무 영역, 제공서비스
  - 구성원 역량, 운영 조직 구조
  - 서비스 변경/배포 빈도
  - 사용량 : 트랜잭션 빈도
  - 데이터베이스 주제 영역 / 오너쉽

### 2.5. 도메인 주도 설계
- How 관점
- 업무 경계 (바운디드 컨텍스트, 어그리거드)

### 2.6. 시스템 복잡성
- 로컬 복잡성 : 각각의 개별 마이크로서비스의 복잡성
- 글로벌 복잡성 : 전체 시스템의 복잡성, 서비스 간의 상호작용과 의존성

### 2.7. 서브 시스템, 업무 영역
- 기능 분해를 통해 도출
- What 관점 : 업무를 제공하는 서비스, 비지니스 능력(조직이 하는 일)

### 2.8. 백 엔드 설계
- 비지니스 로직 설계 : 도메인 모델링
- 데이터 설계 : 데이터 모델링
- API 설계
  - REST API 설계 원칙
  - 성숙도

### 2.9. REST API 설계
- Contract(계약)
- REST 구성
  - Representational State Transfer : 자원의 정보를 주고 받는 구조
  - 자원(Resource) : URI 로 표햔(http://service/apis)
  - 행위(Verb) : HTTP Method(POST, GET, PUT, DELETE)
  - 표현(Representations) : HTTP POST http://service/apis {"apis" : {"name" : "sample"}}
- 행위 : HTTP Method 활용
  - POST   : 리소스 생성
  - GET    : 리소스 조회
  - PUT    : 리소스 수정
  - DELETE : 리소스 삭제
- HTTP 상태 코드
  - 200-level 성공
  - 400-level 잘못된 요청
  - 500-level 서버 에러
- REST API 디자인 가이드
  - Web API Design (http://www.apigee.com)
    - https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf
    - REST API 설계는 아키텍처 스타일이지 표준은 아님. 유연하게 적용
    - API 의 목표는 개발자의 생산성과 성공을 극대화(실용주의)
- 자원
  - 간결하고 직관적인 기준 URL 유지. 가이드 문서가 필요없도록
  - 자원(Resource) 별로 두 가지 형식의 기준 URL 사용
    - GET /dogs      : 목록 조회
    - POST /dogs     : 개체 생성
    - PUT /dogs/1    : 1번 개체 수정
    - DELETE /dogs/1 : 1번 개체 삭제
    - GET /dogs/1    : 1번 개체 조회
  - 동사 보다는 명사 사용, 단수 명사보다는 복수 사용
    - /getDogs, /setDogs : X
    - GET /dogs, POST /dogs/{puppy}/owner/{terry}
- Idempotent (멱등성), Not Post
- Stateless, easy scale
- Versioning
  - /v1/products
  - /v2/products
- REST API 성숙도 모델
  - Richardson Maturity Model
  - https://martinfowler.com/articles/richardsonMaturityModel.html
    - Level 0: RPC
    - Level 1 : Resources
    - Level 2 : HTTP Verbs
    - Level 3: HATEOAS(Hypermedia As The Engine Of Application State)
- 명세방법 : 문서, Swagger

### 2.10. 프론트 엔드 설계
- UI 레이아웃 정의
  - 화면 흐름
  - UI 입출력 항목, 이벤트

## 3. 도메인 주도 설계(전략적 설계)
### 3.1. 마이크로서비스 설계
- 마이크로서비스는 어떤 기준으로 분리할 것인가?
  - Bounded Context, Ubiquitous Language
- 서비스 간은 어떻게 연계할 것인가?
  - Context Mapping
- 어떤 이벤트에 의해 마이크로서비스는 서로 반응하는가?
  - Domain Event
- 마이크로서비스 내부는 어떻게 설계할 것인가?
  - Domain Model

### 3.2. 도메인 주도 설계란?
- 구축해야 하는 소프트웨어, 시스템을 위해서는 문제를 이해해야 함
- 문제 : 그 조직의 비즈니스 전략과 소프트웨어를 통해서 얻고자 하는 가치를 의미
- 문제를 이해하려면 그것이 존재하는 맥락을 이해해야 함
- 비지니스 도메인 이란 : 기업의 주요 활동 영역, 회사가 제공하는 서비스
- Sub domain(하위 도메인) : 비즈니스 활동의 세분화된 영역, 제공하는 서비스 단위

### 3.3 Sub Domain(하위 도메인)
- 하위 도메인 유형
  - 핵심(Core)
    - 회사가 경쟁업체와 다르게 수행하고 있는 것
    - 복잡성 높지만 Biz 경쟁력 제공
    - Ex) 우버의 방향에 따른 손님 매칭 서비스, 구글의 검색 순위 알고리즘
  - 일반(Generic)
    - 모든 회사가 같은 방식으로 수행하는 비지니스 활동
    - 복잡하고 구현하기 어려우나, 경쟁력을 제공하지는 않음. 알려진 영역
    - Ex) 인증, 권한 부여
  - 지원(Supporting)
    - 회사 비지니스 지원 활동
    - 기능 간단, 어떠한 경쟁우위 제공하지 않음
    - CRUD, ETL
- 하위 도메인 유형에 따른 구현 방법
  - 핵심(Core)
    - 사내에서 구현, 조직의 핵심 숙련 인재 할당
    - 자주 지속적으로 변경 예상되므로 가장 진보된 엔지니어링 기술 적용
  - 일반(Generic)
    - 이미 만들어진 제품, 오픈 소스 솔루션
  - 지원(Supporting)
    - 사내에서 구현하지 않음
    - 정교한 디자인 패턴이나 고급 엔지니어링 기술 필요 없음
    - 새로운 인재 양성을 위한 연습 기회 제공
- 하위 도메인 식별
  - 이미 존재
  - 회사의 부서, 조직 단위
  - 응집된 유스케이스 집합

### 3.4. 멘탈모델과 도메인 지식
- 도메인 지식 : 도메인 전문가가 문제를 생각하는 방식, 즉 멘탈 모델
- 문제를 해결하기 위해서는 문제를 이해해야 함
- 기존의 과정에서는 변환의 과정을 거침
- 도메인 주도 설계에서는 도메인 지식을 변환하는 대신 도메인을 설명하기 위한 단일화된 체계 : 유비쿼터스 언어
- 기술 용어 X, 비지니스 도메인에 관련된 용어

### 3.5. 유비쿼터스 언어
- 정확하고 일관성 있는 용어 사용, 모호한 용어 X
- 예를 들어 정책이란 용어는 규제 규칙, 보험계약 같은 여러 가지 의미를 가짐. 정확한 의미는 맥락에 따라 사람과의 상호작용에 따라 다름, 정책(X) -> 규제 규칙, 보험계약 과 같이 명확하게 정의해야 함
- 동의어 X
- 사용자 X -> 방문자, 계정

### 3.6. 도메인 모델
- 효과적인 모델은 그 목적을 달성하는 데 필요한 세부사항만 포함한다
- 실 세계의 복사본이 아니라 문제를 해결하려는 의도가 있으며, 그 목적에 필요한 정보만 제공해야 한다
- 'All models are wrong, some are useful'
- 모델은 본질적으로 추상화의 결과이다
- 모델로써 실 세계의 복잡성을 관리
- 도메인 모델링 : 유비쿼터스 언어로 사실상 비즈니스 도메인 모델을 구축하는 것
- 명사와 행위 파악

### 3.7. 진흙 덩어리(Big ball of Mud)
- 소프트웨어 복잡성은 본질적인 도메인 복잡함과 우발적인 기술 복잡성의 혼합의 결과물
- 용어 충돌, 모호성
- Ex) 거대한 ERD
- bounded Context : 맥락의 경계, 유비쿼터스 언어를 여러 개의 작은 언어로 나눈 다음 각 언어를 적용할 수 있는 명시적인 bounded Context 에 할당

### 3.8. bounded Context(바운디드 컨텍스트)
- 모델의 경계
- 바운디드 컨텍스트는 유비쿼터스 일관성이 유지되는 경계
- 유비쿼터스 언어의 용어, 원칙, 비지니스 규칙은 해당 바운디드 컨텍스트 내에서만 일관성이 있다
  - Ex) Customer
    - Order - 주문하는 사람
    - Accounting - 시스템 고객
    - Delivery - 배송 받는 사람

### 3.9. 바운디드 컨텍스트와 도메인 모델
- 도메인 모델 : 특정 도메인을 개념적으로 표현한 것
- 도메인의 핵심 규칙을 구현
- 바운디드 컨텍스트가 이후 세분화될 수도 있음
  - 컴포넌트 개발 수명주기 분리할 필요가 있거나 기능이 독립적으로 확장해야 할 경우
- 각 BC 의 수명 주기는 독립적
- 물리적 경계 역할, 소유권 경계
- 바운디드 컨텍스트와 하위 도메인 차이
  - 하위 도메인은 비지니스 전략에 의해 정의됨. 반면에 바운디드 컨텍스트는 소프트웨어 엔지니어에 의해 설계됨
  - 하위 도메인은 발견되고 바운디드 컨텍스트는 설계한다는 점

### 3.10. 컨텍스트 매핑 (Context Mapping)
- BC 는 서로 독립적으로 발전할 수 있지만 상호작용해야 한다. 즉 각 BC 는 접점이 있다. 이를 contract 라 함
- BC 의 연동, 통합 : 각 바운디드 컨텍스트에서 작업하는 팀 간의 관계를 의미하기도 함
- 협력형 패턴 그룹
- 사용자-제공자
- 분리형 노선

### 3.11. 협력형 패턴
- 파트너십
- 공유 영역

### 3.12. 공급자, 소비자 패턴
- Supplier - customer
  - Upstream, downstream
- Conformist(순응주의자)
  - 힘의 균형은 상류에 존재
- ACL(충돌방지계층)
  - 하류가 이에 순응하지 않은 경우
- OHS(오픈 호스트 서비스)
  - 힘이 사용자 측에 있을 경우, 제공자는 사용자를 보호하고 가능한 최고의 서비스를 제공
  - 여러 사용자에 따른 버전 관리 가능
- 공개 프로토콜, 공표된 언어(PL)
  - 명세

### 3.13. 분리형 노선
- 각자의 길(separated way)
- 커뮤니케이션 어려움
- 협력과 연동보다는 특정 기능을 중복으로 두는 것이 더 저렴한 경우

### 3.14. 이벤트 스토밍
- 이벤트 스토밍 개념
  - Eric Evans 와 Domain Language Inc. 가 인증한 Domain-Driven Design 강사
  - 마이크로서비스 설계를 위한 워크샵
  - 이해관계자 모두 참여
- 이벤트 스토밍 구성요소
  - Domain Event
    - 시스템에서 발생하는 중요한 이벤트
    - 데이터가 아닌 "비즈니스 프로세스" 에 집중
    - "과거 형 동사" 로 표현
  - Hot Spot
    - 질문, 가정, 경고, 의견 수렴이 필요한 내용
    - 병목 구간, 자동화 필요한 수작업, 도메인 지식이 없는 경우
    - 완전히 정의되지 않은 영역, 해결해야 하는 문제
    - 필요한 곳 어디에나 부착 가능
  - Command
    - 이벤트를 트리거 하는 명령
    - "현재 동사" 로 표현
  - Actor
    - Command 를 동작하게 하는 사용자/역할
    - "사람" 이나 "역할의 이름" 을 "명사(단어)" 로 표현
  - Policy
    - 자동화 정책 : 이벤트가 커맨드를 시작하는 시나리오
    - 커맨드는 특정 도메인 이벤트가 발생할 때 자동 실행된다
    - (이벤트) 할 때는 항상 (커멘드) 한다
  - External System
    - 연계가 필요한 외부 시스템 또는 프로세스
    - "명사(단어)" 로 표현
  - Aggregate
    - Domain Event 와 Command 에 의해 관리되는 데이터
    - Domain Event 와 Command 를 표현하는 키워드
    - "명사(단어)" 로 표현
